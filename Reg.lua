-- **********************正则表达式************************
--  ##语法：
--       ^  :   开头 
--       $  :   结束
--       . :   匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
--       /s :   空格
--       /n :   换行
--       * :   匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
--       + :   匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
--       ? :   匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}

-- **************************示例**************************
    -- 1. ^function.*:test.*$   :   以function开头 ， 中间含有 :test 的整体一行 
    --         <======> ^function.*:test.{0,}$

    -- 2. 判断字符串是否是有空格组成
    -- local test = string.match("    ", "^[ ]*$") ---[[如果全是空格返回字符串，否则返回nil]]
    -- 匹配非法字符 [`~!@#_$%^&*()+=|{}':;',<>/?~！@#￥%……&*（）——+|{}【】《》 ‘；：”“’"。，、？\[\]-] 除开.


    -- ((?<=(>|])).*?(?=(<|\[|$)))  输出ubb内容
    -- (?:pattern) 
    -- 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
    -- (?=pattern)
    -- 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
    -- (?!pattern)
    -- 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
    -- (?<=pattern)
    -- 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。
    -- (?<!pattern)
    -- 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 